syntax = "proto3";

package yarrow;

import "types.proto";

message Analysis {
    map<uint32, Component> graph = 1;
    PrivacyDefinition privacy_definition = 2;
}

message PrivacyDefinition {
    // upper bound
    double epsilon = 1;
    double delta = 2;
    double rho = 3;

    uint32 group_size = 4;

    enum Distance {
        // (e, 0)-differential privacy
        PURE = 0;

        // (e, d)-differential privacy
        APPROXIMATE = 1;

        // https://arxiv.org/pdf/1702.07476.pdf
        RENYI = 2;

        // https://arxiv.org/pdf/1603.01887.pdf
        CONCENTRATED = 3;

        // https://arxiv.org/pdf/1905.02383.pdf
        F = 4;
    }
    Distance distance = 5;

    enum Neighboring {
        SUBSTITUTE = 0;
        ADD_REMOVE = 1;
    }
    Neighboring neighboring = 6;
}

message Component {
    // uint32 value is source_node_id
    map<string, uint32> arguments = 1;

    oneof value {
        Add add = 2;
        Laplace laplace = 3;
        Literal literal = 4;
        Constant constant = 5;
        Mean mean = 6;
        DataSource datasource = 7;
        DPMean dpmean = 8;
        Clamp clamp = 9;
        Subtract subtract = 10;
        Divide divide = 11;
        Multiply multiply = 12;
        Power power = 13;
        Negate negate = 14;
        Bin bin = 15;
        // Count count = 17;
        // Histogram histogram = 17;
        Median median = 16;
        Sum sum = 17;
        Variance variance = 18;
        ImputeF64Uniform impute_f64_uniform = 19;
        ImputeF64Gaussian impute_f64_gaussian = 20;
        ImputeI64Uniform impute_i64_uniform = 21;
        DPVariance dpvariance = 22;
        DPMomentRaw dpmomentraw = 23;
        DPCovariance dpcovariance = 24;
        LaplaceMechanism laplace_mechanism = 25;
        GaussianMechanism gaussian_mechanism = 26;
        SimpleGeometricMechanism simple_geometric_mechanism = 27;
        KthRawSampleMoment kth_raw_sample_moment = 28;
    }

}

message Add {}
message Subtract {}
message Divide {}
message Multiply {}
message Power {}
message Negate {}
message Bin {
    ArrayND edges = 1;
    bool inclusive_left = 2;
}
message Clamp {
    double min = 1;
    double max = 2;
}
// message Count {
//     // CC TODO: need to figure out how to add groupby Option
// }
// message Histogram {}
message Mean {}
message Variance {
    bool finite_sample_correction = 1;
}
message KthRawSampleMoment {
    int64 k = 1;
}
message Median {}
message Sum {}
message ImputeF64Uniform {
    double min = 1;
    double max = 2;
}
message ImputeF64Gaussian {
    double shift = 1;
    double scale = 2;
    double min = 3;
    double max = 4;
}
message ImputeI64Uniform {
    double min = 1;
    double max = 2;
}

message Laplace {
    double epsilon = 1;
}
message Literal {
    ArrayND value = 1;
}
message Constant {}
message DataSource {
    string dataset_id = 1;
    string column_id = 2;

    // TODO: constraints/nature should be moved to arguments, THEY ARE PRIVATE
    // TODO: is nature necessary? if categorical, then could cast the other types to strings
    DataType datatype = 3;
    enum Nature {
        UNKNOWN = 0;
        CONTINUOUS = 1;
        CATEGORICAL = 2;
    }
    Nature nature = 4;

    // should be a 1D array of the unique values (likely bool, int, or string)
    ArrayND constraints = 5;
}

message DPMean {
    double epsilon = 1;
    Mechanism mechanism = 2;
}
message DPVariance {
    double epsilon = 1;
    Mechanism mechanism = 2;
}

message DPMomentRaw {
    double epsilon = 1;
    Mechanism mechanism = 2;
    uint32 order = 3;
}

message DPCovariance {
    double epsilon = 1;
    Mechanism mechanism = 2;
}

message LaplaceMechanism {
    double epsilon = 1;
}
message GaussianMechanism {
    double epsilon = 1;
}
message SimpleGeometricMechanism {
    double epsilon = 1;
    int64 count_min = 2;
    int64 count_max = 3;
    bool enforce_constant_time = 4;
}