## Differential Privacy Proposal

This is a proposal for what a centralized differential privacy library might look like.  

### Current state
The final decision on what compiled language to use is still out. All demos/projects implement protobuf code generation, protobuf serialization/deserialization, communication over FFI, and redistributable package/library artifacts, and have at some point compiled cross-platform (more testing needed). All projects communicate via proto definitions from the `prototypes` directory.  

#### Validators
There are two proof of concept validators, one in Haskell, one in C++. Both compile to binaries that expose C foreign function interfaces and read/automatically generate code for protobuf. A validator C FFI is described in the wiki.  

The C++ validator splits autogenerated proto code into a separate library. Dependencies are handled with Conan, builds by CMake.  

The haskell validator works in a development environment, but due to limitations in the cabal build system, generated libraries do not statically link dependencies or the haskell runtime. This issue blocks distribution/embedding of the library in language bindings.  

The best decision would be to write the validator in Rust- based on the tooling around the language, package management, memory safety and security. There is also a relatively stable differential privacy Rust runtime.  

#### Runtimes
There are two runtimes implemented, one in Rust, one in C++.   

The Rust runtime uses a package called ndarray, which feels somewhat like writing numpy in Rust.  

The C++ runtime uses the eigen package. It is not as well tested or stable as Rust, but it can handle some limited graph evaluation.  

#### Bindings
There are two language bindings, one in Python, one in R. Both support building binaries into an installable package. Currently only bindings to the Rust runtime are properly bound into the distributable packages, while validators are dynamically loaded.  

The Python package is more developed, with helper classes, syntax sugar for building analyses, and visualizations.  

The R package uses a shim library in C to interface with compiled binaries. There isn't a programmer interface like in Python yet, but there is a pattern for exposing the C FFI in R code, as well as protobuf generation.  

The steps for adding bindings in a new language are essentially:  
1. set up package management  
2. set up dependency management  
3. pack binaries with the given language's tools  
4. protobuf code generation  
5. FFI implementation and protobuf encoding/decoding  
6. write programmer interface  


### Install
1. clone the repository  


    git clone $REPOSITORY_URI

2. Install protobuf compiler from source  
    Mac:  
        - install xcode `sudo xcode-select --install`  
        - install macports https://www.macports.org/install.php  
        - install unix make tools `sudo /opt/local/bin/port install autoconf automake libtool`  
        - continue on with the Ubuntu install directions  
    Ubuntu:  
        - download the "all" Github release. Use version 3.9.x (because of conan)  
          `https://github.com/protocolbuffers/protobuf/releases/download/v3.9.1/protobuf-all-3.9.1.zip`  
        - Follow the Protobuf instructions, starting from `./configure`  
          `https://github.com/protocolbuffers/protobuf/blob/master/src/README.md`  
          NOTE: move to a directory without spaces in the path  
    Windows:
* download and run installer, accepting defaults, then add /bin directories to PATH
  + Git
  + 7z
  + CMake
  + Mingw-w64
  + Visual Studio Code
* get source for protobuf
  + `git clone https://github.com/protocolbuffers/protobuf/protobuf.git`
  + `cd protobuf`
  + `git submodule update --init --recursive`
* open the code in integrated developer environment
  + launch Windows command prompt
  + `cd path_to_cloned_protobuf_repo`
  + `code .`
* OPTIONAL: configure build in Visual Studio Code
  + https://code.visualstudio.com/docs/cpp/config-mingw#_create-hello-world
  + follow tutorial to build a C++ Hello World, compiled with Mingw-w64
  + Terminal > Configure Default Build Task > C/C++: g++.exe build active file
  + Terminal > Tasks: Run Build Task
* configure and build protobuf
  + `cd path_to_cloned_protobuf_repo\cmake`
  + `mkdir build\release & cd build\release`
  + invoke CMake to create and build the Makefile artifacts
  + `cmake -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=..\..\..\install -DCMAKE_C_COMPILER=gcc.exe -DCMAKE_CXX_COMPILER=g++.exe ..\..`
* compile and test protobuf
  + `cd path_to_cloned_protobuf_repo\cmake\build\release`
  + `mingw32-make all`

Installation instructions for sub-projects are provided in their README.md's.
